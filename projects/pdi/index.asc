
:stem:
:toc: left
:toc-title: Sumário
:last-update-label!:
:source-highlighter: pygments

= Respostas Exercícios de PDI
Gabriel Vantuil
Luiz Felipe Maciel Correia 
:appversion: 1.0.0

Site para hospedagem das respostas dos exercicios propostos no 
link:http://agostinhobritojr.github.io/tutoriais/pdi/[tutorial^] do Prof. Dr. Agostinho Brito Jr. 

== Exercicios 2.2 ==

Esta seção é apenas uma introdução a manipulação dos pixels de uma imagem usando diretamente o metodo .at da classe Mat.

=== Exercício 2.2.1 - Regions ===

* Desenvolvimento:

É solicitado ao usuário dois pontos pertecentes ao interior da imagem. Logo depois a área definida pelos pontos 
de interesse é preenchida com a negativa da cor anterior. Para encontrar esse valor, basta fazer (255 - valor_antigo). 
	
* Resultados:

Ao testar o algoritmo foi informado P1 = (10,10) e P2 = (100,150) para inverter a cor.

[[fig_regionsR, Regions]]
//[.text-center]
.Saída do programa Regions
image::2.2/Regions/resultado.png[title="Saída do programa Regions"]

* Código: 

[[exa_regions, Regions]]
[source,cpp]
.regions.cpp
----
include::2.2/Regions/regions.cpp[]
----

=== Exercício 2.2.2 - TrocaRegioes ===

* Desenvolvimento:

O primeiro passo para realizar a troca é armazenar a matriz original, e trabalhar em cima de uma outra matriz para 
que não haja perda de informações. Logo após ocorre a troca, que consiste em 4 laços onde ocorrem as cópias
 dos quadrantes para o quadrante da diagonal.

* Resultados:

Utilizado a imagem biel.png.

[[fig_trocaregioesE, Regions]]
//[.text-center]
.Saída do programa TrocaRegioes
image::2.2/Trocaregioes/resultado.png[title="Saída do programa TrocaRegioes"]

* Código: 

[[exa_trocaregioes, Regions]]
[source,cpp]
.trocaregioes.cpp
----
include::2.2/Trocaregioes/trocaregioes.cpp[]
----

== Exercicios 3.2 ==

Esta seção é uma introdução a indentificação de objetos na imagem, juntamente com noções do uso da função floodFill() do 
OpenCV.

=== Exercício 3.2.1 - Solução ===

* Desenvolvimento:
Para solucionar o problema de muitos objetos, foi utilizado um algoritmo que classifica cada objeto com uma cor diferente do 
espaço RGB, sendo que a classificação começa com (0,0,0), e começa a incrementar o vermelho, quando o vermelho alcançar 255 
incrementa o verde e zera o vermelho, o mesmo para azul e verde.

 A sequência fica:
(0,0,0), 
(0,0,1) 
...
(0,0,255), 
(0,1,0), 
(0,1,1),
...
(0,255,255),
(1,0,0), 
 ...
(255,255,255).

* Resultados:

[[fig_solucaoI, Solucao]]
//[.text-center]
.Saída do programa Solucao
image::3.2/3.2.1/resultado.png[title="Saída do programa Solucao"]

* Código: 

[[exa_solucao, Solucao]]
[source,cpp]
.labeling_3.2.1.cpp
----
include::3.2/3.2.1/labeling_3.2.1.cpp[]
----

=== Exercício 3.2.2 - ContaBuracos ===

* Desenvolvimento:

* Resultados:
** Passo 1: Retirar bolhas das bordas.
** Passo 2: Contagem e Rotulação das bolhas como no exemplo.
** Passo 3: Preencher o fundo com outro tom de cinza.
** Passo 4: Contar e Rotular o(s) buracos(s) de cada bolha.

Aṕos o procedimento é mostrado no terminal a quantidade de bolhas encontradas. 

[[fig_contaburacos1, ContaBuracos1]]
//[.text-center]
image::3.2/3.2.2/resultado.png[title="resultado"]

[[fig_contaburacos2, ContaBuracos1]]
//[.text-center]
image::3.2/3.2.2/terminal.png[title="terminal"]

[[exa_contaburacos, ContaBuracos]]
[source,cpp]
.labeling_3.2.2.cpp
----
include::3.2/3.2.2/labeling_3.2.2.cpp[]
----

== Exercícios 4.2 ==

=== Exercício 4.2.1 - Equalize ===

* Desenvolvimento:
Para realizar a equalização de histograma, foi utilizada a função equalizeHist() da biblioteca opencv.

* Resultados:

[[fig_equalize1, Equalize1]]
//[.text-center]
.Imagem Original
image::4.2/Equalize/Original.png[title="Imagem Original"]

[[fig_equalize2, Equalize2]]
//[.text-center]
.Imagem Original
image::4.2/Equalize/Equalizada.png[title="Imagem Equalizada"]

[[exa_equalize, Equalize]]
[source,cpp]
.equalize.cpp
----
include::4.2/Equalize/equalize.cpp[]
----

=== Exercício 4.2.2 - MotionDetector ===

* Desenvolvimento:
Ao detectar a uma SAD (soma de diferenças absolutas) entre dois histogramas maior do que um valor pré definido (no exemplo: 30000),
imprime no terminal a mensagem avisando que houve movimento (significativo) e o valor da SAD.
* Resultados:

[[fig_motiondetector, MotionDetector]]
//[.text-center]
.Terminal do programa MotionDetector
image::4.2/Motiondetector/terminal.png[title="Terminal do programa MotionDetector"]

[[exa_motiondetector, MotionDetector]]
[source,cpp]
.motiondetector.cpp
----
include::4.2/Motiondetector/motiondetector.cpp[]
----

== Exercícios 5.2 ==
* Desenvolvimento:
Para realizar o filtro solicitado, foi realizado o filtro gaussiano, e na sequência o laplaciano. 

* Resultados: 

[[fig_laplgauss1, LaplGauss1]]
//[.text-center]
.Imagem original.
image::5.2/original.png[title="Imagem original"]

[[fig_laplgauss2, LaplGauss2]]
//[.text-center]
.resultado
image::5.2/resultado.png[title="resultado"]

[[exa_laplgauss, LaplGauss]]
[source,cpp]
.laplgauss.cpp
----
include::5.2/laplgauss.cpp[]
----
